/*
 * Copyright (c) 2012, "Johan Maasing" <johan@zoom.nu>
 * All rights reserved.

 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <organization> nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package nu.zoom.jme.inspector.heightfield;

import com.jme3.math.Vector3f;
import java.awt.EventQueue;
import java.lang.management.ManagementFactory;
import java.util.concurrent.atomic.AtomicReference;
import javax.management.MBeanServer;
import nu.zoom.jme.inspector.common.JMETerrainGridInspectorMBean;
import nu.zoom.jme.inspector.common.JMXNames;
import nu.zoom.jme.inspector.common.TerrainQuadInformation;
import static nu.zoom.jme.inspector.heightfield.Bundle.*;
import nu.zoom.jme.inspector.jmx.AppFinder;
import nu.zoom.jme.inspector.jmx.TerrainQuadRefresher;
import nu.zoom.jme.inspector.jmx.TerrainQuadRefresherListener;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.DialogDisplayer;
import org.openide.NotifyDescriptor;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.awt.StatusDisplayer;
import org.openide.util.NbBundle;
import org.openide.util.NbBundle.Messages;
import org.openide.windows.TopComponent;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(dtd = "-//nu.zoom.jme.inspector.heightfield//HeightFieldVisualizer//EN",
autostore = false)
@TopComponent.Description(preferredID = "HeightFieldVisualizerTopComponent",
iconBase = "nu/zoom/jme/inspector/heightfield/picture.png",
persistenceType = TopComponent.PERSISTENCE_ALWAYS)
@TopComponent.Registration(mode = "editor", openAtStartup = false)
@ActionID(category = "Window", id = "nu.zoom.jme.inspector.heightfield.HeightFieldVisualizerTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(displayName = "#CTL_HeightFieldVisualizerAction",
preferredID = "HeightFieldVisualizerTopComponent")
public final class HeightFieldVisualizerTopComponent extends TopComponent implements TerrainQuadRefresherListener {

    private final AppFinder appFinder;
    private final MBeanServer mbeanServer;
    private boolean attached = false;
    private AtomicReference<JMETerrainGridInspectorMBean> terrainGridInspectorRef =
            new AtomicReference<JMETerrainGridInspectorMBean>();
    private TerrainQuadRefresher refresher;

    public HeightFieldVisualizerTopComponent() {
        this.mbeanServer = ManagementFactory.getPlatformMBeanServer();
        this.appFinder = new AppFinder(this.mbeanServer, this);
        initComponents();
        setName(NbBundle.getMessage(HeightFieldVisualizerTopComponent.class, "CTL_HeightFieldVisualizerTopComponent"));
        setToolTipText(NbBundle.getMessage(HeightFieldVisualizerTopComponent.class, "HINT_HeightFieldVisualizerTopComponent"));
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        mainToolBar = new javax.swing.JToolBar();
        portLabel = new javax.swing.JLabel();
        portTextField = new javax.swing.JTextField();
        attachButton = new javax.swing.JToggleButton();
        attachSelectorSeparator = new javax.swing.JToolBar.Separator();
        remoteOperationProgressbar = new javax.swing.JProgressBar();
        mainSplitter = new javax.swing.JSplitPane();
        imageComponentScroller = new javax.swing.JScrollPane();
        heightFieldImageBean = new nu.zoom.jme.inspector.heightfield.HeightFieldImageBean();
        imageInfoScroller = new javax.swing.JScrollPane();
        imageInfoPanel = new javax.swing.JPanel();
        sizeLabel = new javax.swing.JLabel();
        sizeValue = new javax.swing.JLabel();
        minRangeLabel = new javax.swing.JLabel();
        minRangeValue = new javax.swing.JLabel();
        maxRangeLabel = new javax.swing.JLabel();
        maxRangeValue = new javax.swing.JLabel();
        cellLabel = new javax.swing.JLabel();
        cellValue = new javax.swing.JLabel();
        nameLabel = new javax.swing.JLabel();
        nameValue = new javax.swing.JLabel();

        mainToolBar.setRollover(true);

        portLabel.setLabelFor(portTextField);
        org.openide.awt.Mnemonics.setLocalizedText(portLabel, org.openide.util.NbBundle.getMessage(HeightFieldVisualizerTopComponent.class, "HeightFieldVisualizerTopComponent.portLabel.text")); // NOI18N
        mainToolBar.add(portLabel);

        portTextField.setText(JMXNames.INSPECTOR_SERVER_RMI_NAME);
        mainToolBar.add(portTextField);

        org.openide.awt.Mnemonics.setLocalizedText(attachButton, org.openide.util.NbBundle.getMessage(HeightFieldVisualizerTopComponent.class, "HeightFieldVisualizerTopComponent.attachButton.text")); // NOI18N
        attachButton.setFocusable(false);
        attachButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        attachButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        attachButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                attachButtonActionPerformed(evt);
            }
        });
        mainToolBar.add(attachButton);
        mainToolBar.add(attachSelectorSeparator);

        mainToolBar.add(remoteOperationProgressbar);

        javax.swing.GroupLayout heightFieldImageBeanLayout = new javax.swing.GroupLayout(heightFieldImageBean);
        heightFieldImageBean.setLayout(heightFieldImageBeanLayout);
        heightFieldImageBeanLayout.setHorizontalGroup(
            heightFieldImageBeanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 257, Short.MAX_VALUE)
        );
        heightFieldImageBeanLayout.setVerticalGroup(
            heightFieldImageBeanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 319, Short.MAX_VALUE)
        );

        imageComponentScroller.setViewportView(heightFieldImageBean);

        mainSplitter.setLeftComponent(imageComponentScroller);

        org.openide.awt.Mnemonics.setLocalizedText(sizeLabel, org.openide.util.NbBundle.getMessage(HeightFieldVisualizerTopComponent.class, "HeightFieldVisualizerTopComponent.sizeLabel.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(sizeValue, org.openide.util.NbBundle.getMessage(HeightFieldVisualizerTopComponent.class, "HeightFieldVisualizerTopComponent.sizeValue.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(minRangeLabel, org.openide.util.NbBundle.getMessage(HeightFieldVisualizerTopComponent.class, "HeightFieldVisualizerTopComponent.minRangeLabel.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(minRangeValue, org.openide.util.NbBundle.getMessage(HeightFieldVisualizerTopComponent.class, "HeightFieldVisualizerTopComponent.minRangeValue.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(maxRangeLabel, org.openide.util.NbBundle.getMessage(HeightFieldVisualizerTopComponent.class, "HeightFieldVisualizerTopComponent.maxRangeLabel.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(maxRangeValue, org.openide.util.NbBundle.getMessage(HeightFieldVisualizerTopComponent.class, "HeightFieldVisualizerTopComponent.maxRangeValue.text")); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(cellLabel, org.openide.util.NbBundle.getMessage(HeightFieldVisualizerTopComponent.class, "HeightFieldVisualizerTopComponent.cellLabel.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(cellValue, org.openide.util.NbBundle.getMessage(HeightFieldVisualizerTopComponent.class, "HeightFieldVisualizerTopComponent.cellValue.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(nameLabel, org.openide.util.NbBundle.getMessage(HeightFieldVisualizerTopComponent.class, "HeightFieldVisualizerTopComponent.nameLabel.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(nameValue, org.openide.util.NbBundle.getMessage(HeightFieldVisualizerTopComponent.class, "HeightFieldVisualizerTopComponent.nameValue.text")); // NOI18N

        javax.swing.GroupLayout imageInfoPanelLayout = new javax.swing.GroupLayout(imageInfoPanel);
        imageInfoPanel.setLayout(imageInfoPanelLayout);
        imageInfoPanelLayout.setHorizontalGroup(
            imageInfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(imageInfoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(imageInfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(nameLabel)
                    .addComponent(cellLabel)
                .addGroup(imageInfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(maxRangeLabel)
                    .addComponent(sizeLabel, javax.swing.GroupLayout.Alignment.TRAILING)
                        .addComponent(minRangeLabel, javax.swing.GroupLayout.Alignment.TRAILING)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(imageInfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(sizeValue, javax.swing.GroupLayout.DEFAULT_SIZE, 238, Short.MAX_VALUE)
                    .addComponent(minRangeValue, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(maxRangeValue, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(cellValue, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(nameValue, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        imageInfoPanelLayout.setVerticalGroup(
            imageInfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(imageInfoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(imageInfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(cellLabel)
                    .addComponent(cellValue))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(imageInfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(minRangeLabel)
                    .addComponent(minRangeValue))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(imageInfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(maxRangeLabel)
                    .addComponent(maxRangeValue))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(imageInfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(sizeLabel)
                    .addComponent(sizeValue))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(imageInfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(nameLabel)
                    .addComponent(nameValue))
                .addContainerGap(198, Short.MAX_VALUE))
        );

        imageInfoScroller.setViewportView(imageInfoPanel);

        mainSplitter.setRightComponent(imageInfoScroller);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(mainToolBar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(mainSplitter)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(mainToolBar, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(mainSplitter))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void attachButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_attachButtonActionPerformed
        if (this.appFinder.isAttached()) {
            this.appFinder.detach();
            // Appfinder will callback to us to stop the terrain refresher.
        } else {
            this.appFinder.attach(portTextField.getText());
        }
    }//GEN-LAST:event_attachButtonActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JToggleButton attachButton;
    private javax.swing.JToolBar.Separator attachSelectorSeparator;
    private javax.swing.JLabel cellLabel;
    private javax.swing.JLabel cellValue;
    private nu.zoom.jme.inspector.heightfield.HeightFieldImageBean heightFieldImageBean;
    private javax.swing.JScrollPane imageComponentScroller;
    private javax.swing.JPanel imageInfoPanel;
    private javax.swing.JScrollPane imageInfoScroller;
    private javax.swing.JSplitPane mainSplitter;
    private javax.swing.JToolBar mainToolBar;
    private javax.swing.JLabel maxRangeLabel;
    private javax.swing.JLabel maxRangeValue;
    private javax.swing.JLabel minRangeLabel;
    private javax.swing.JLabel minRangeValue;
    private javax.swing.JLabel nameLabel;
    private javax.swing.JLabel nameValue;
    private javax.swing.JLabel portLabel;
    private javax.swing.JTextField portTextField;
    private javax.swing.JProgressBar remoteOperationProgressbar;
    private javax.swing.JLabel sizeLabel;
    private javax.swing.JLabel sizeValue;
    // End of variables declaration//GEN-END:variables

    @Override
    public void componentOpened() {
        this.appFinder.startTimer();
    }

    @Override
    public void componentClosed() {
        this.appFinder.stopTimer();
    }

    void writeProperties(java.util.Properties p) {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
    }

    void readProperties(java.util.Properties p) {
        String version = p.getProperty("version");
    }

    /**
     * Set background operation indicators on or off. May be called from any
     * thread.
     *
     * @param running true to show a background operation is in progress. false
     * to shut off the indicators.
     */
    public void indicateBackgroundOperation(final boolean running) {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                attachButton.setEnabled(!running);
                remoteOperationProgressbar.setIndeterminate(running);
                portTextField.setEnabled(!running);
            }
        });
    }

    /**
     * Callback methoid for the AppFinder to indicate a connection error.
     *
     * @param ex
     */
    public void indicateConnectionError(Exception ex) {
        final NotifyDescriptor descriptor = new NotifyDescriptor.Message(
                ex.getMessage() + "\n" + ex.getLocalizedMessage(),
                NotifyDescriptor.Message.ERROR_MESSAGE);
        DialogDisplayer.getDefault().notify(descriptor);
    }

    /**
     * Get the inspector. Safe to call from any thread.
     *
     * @return The inspector, may be null if the inspector has not been found.
     */
    public JMETerrainGridInspectorMBean getTerrainGridInspector() {
        return this.terrainGridInspectorRef.get();
    }

    /**
     * Use this inspector to draw images. Safe to call from any thread. This is
     * a callback method for the AppFinder when it has attached to the remote
     * server and retrieved a reference to a grid inspector. It will also be
     * called when the app finder detaches (with a null argument).
     *
     * @param terrainGridInspector The new inspector or null.
     */
    @Messages({
        "CTL_Disconnected=Disconnected",
        "CTL_Connected=Connected"})
    public void setTerrainGridInspector(
            final JMETerrainGridInspectorMBean terrainGridInspector) {
        this.terrainGridInspectorRef.set(terrainGridInspector);
        if (terrainGridInspector != null) {
            // Connected
            if (this.refresher != null) {
                this.refresher.stop();
            }
            this.refresher = new TerrainQuadRefresher(
                    terrainGridInspector);
            this.refresher.addListener(heightFieldImageBean);
            this.refresher.addListener(this);
            this.refresher.start();
            EventQueue.invokeLater(new Runnable() {
                @Override
                public void run() {
                    portTextField.setEnabled(false);
                    attachButton.setSelected(true);
            StatusDisplayer.getDefault().setStatusText(
                            CTL_Connected());
                }
            });

        } else {
            // Disconnected
            if (this.refresher != null) {
                this.refresher.stop();
            }
            EventQueue.invokeLater(new Runnable() {
                @Override
                public void run() {
                    attachButton.setSelected(false);
                    StatusDisplayer.getDefault().setStatusText(
                            CTL_Disconnected());
                    portTextField.setEnabled(true);
                }
            });
        }
    }

    @Override
    public void newTerrainQuad(final TerrainQuadInformation terrainQuadInformation) {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                float min = 0;
                float max = 0;

                float[] heightmap = terrainQuadInformation.getHeightmap();
                if (heightmap != null) {
                    for (int n = 0; n < heightmap.length; n++) {
                        max = Math.max(max, heightmap[n]);
                        min = Math.min(min, heightmap[n]);
                    }
                }
                sizeValue.setText("" + terrainQuadInformation.getSize());
                minRangeValue.setText("" + min);
                maxRangeValue.setText("" + max);
                final Vector3f cell = terrainQuadInformation.getCell();
                cellValue.setText(cell.x + ", " + cell.y + ", " + cell.z);
                nameValue.setText(terrainQuadInformation.getName());
            }
        });
    }

    /**
     * Callback from the terrain refresher that it has lost connection to the
     * remote server.
     */
    @Override
    public void disconnected() {
        this.appFinder.detach();
    }
}
